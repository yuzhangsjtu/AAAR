<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; 第3章 提示词不是方法论 – AAAR：AI加速学术研究的方法论与经验</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../outline/04-信息压缩与文献整理.html" rel="next">
<link href="../outline/02-幻觉偏差泄露.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-99913b7803b80b0c1d2b970a25816663.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400;1,700&family=Roboto:ital,wght@0,700;1,300&display=swap');
</style>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
};
</script>


<link rel="stylesheet" href="../css/causal_inference_style.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../outline/03-提示词不是方法论.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">第3章 提示词不是方法论</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">AAAR：AI加速学术研究的方法论与经验</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/yuzhangsjtu/AAAR" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../aaar-ai-accelerating-academic-research.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/00-序章-为什么写这本书.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">序章｜为什么写这本书</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/01-AI能做什么不能做什么.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">第1章 AI能做什么，不能做什么</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/02-幻觉偏差泄露.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">第2章 幻觉、偏差、泄露：三类核心风险</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/03-提示词不是方法论.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">第3章 提示词不是方法论</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/04-信息压缩与文献整理.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">第4章 信息压缩与文献整理</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/05-结构化表达与写作.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">第5章 结构化表达与写作</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/06-代码与计算能力.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">第6章 代码与计算能力</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/07-知识管理与协作.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">第7章 知识管理与协作</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/08-选题与研究问题.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">第8章 选题与研究问题</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/09-文献与理论构建.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">第9章 文献与理论构建</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/10-数据获取与构造.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">第10章 数据获取与构造</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/11-数据清洗与分析.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">第11章 数据清洗与分析</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/12-写作投稿与传播.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">第12章 写作、投稿与传播</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/13-RA-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">第13章 RA Level：工具层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/14-Supervisor-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">第14章 Supervisor Level：认知协作层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/15-Domain-expert-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">第15章 Domain Expert Level：推理与建模层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/16-Agent-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">第16章 Agent Level：AI作为行动者</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/17-Governance-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">第17章 Governance Level：制度与治理层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/18-终章-AI时代研究者的新能力结构.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">终章｜AI时代研究者的新能力结构</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/19-附录.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">附录（可选）</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#一一场关于提示词的迷信" id="toc-一一场关于提示词的迷信" class="nav-link active" data-scroll-target="#一一场关于提示词的迷信"><span class="header-section-number">4.1</span> 一、一场关于提示词的迷信</a></li>
  <li><a href="#二提示词能做什么不能做什么" id="toc-二提示词能做什么不能做什么" class="nav-link" data-scroll-target="#二提示词能做什么不能做什么"><span class="header-section-number">4.2</span> 二、提示词能做什么，不能做什么</a>
  <ul class="collapse">
  <li><a href="#提示词确实有用" id="toc-提示词确实有用" class="nav-link" data-scroll-target="#提示词确实有用">2.1 提示词确实有用</a></li>
  <li><a href="#提示词不能做什么" id="toc-提示词不能做什么" class="nav-link" data-scroll-target="#提示词不能做什么">2.2 提示词不能做什么</a></li>
  <li><a href="#核心区分流程辅助-vs.-判断替代" id="toc-核心区分流程辅助-vs.-判断替代" class="nav-link" data-scroll-target="#核心区分流程辅助-vs.-判断替代">2.3 核心区分：流程辅助 vs.&nbsp;判断替代</a></li>
  </ul></li>
  <li><a href="#三为什么提示词被过度神化" id="toc-三为什么提示词被过度神化" class="nav-link" data-scroll-target="#三为什么提示词被过度神化"><span class="header-section-number">4.3</span> 三、为什么提示词被过度神化</a>
  <ul class="collapse">
  <li><a href="#简单问题的诱惑" id="toc-简单问题的诱惑" class="nav-link" data-scroll-target="#简单问题的诱惑">3.1 简单问题的诱惑</a></li>
  <li><a href="#商业利益的驱动" id="toc-商业利益的驱动" class="nav-link" data-scroll-target="#商业利益的驱动">3.2 商业利益的驱动</a></li>
  <li><a href="#对ai能力的误解" id="toc-对ai能力的误解" class="nav-link" data-scroll-target="#对ai能力的误解">3.3 对AI能力的误解</a></li>
  <li><a href="#可观察性偏差" id="toc-可观察性偏差" class="nav-link" data-scroll-target="#可观察性偏差">3.4 可观察性偏差</a></li>
  </ul></li>
  <li><a href="#四从提问技巧走向研究系统" id="toc-四从提问技巧走向研究系统" class="nav-link" data-scroll-target="#四从提问技巧走向研究系统"><span class="header-section-number">4.4</span> 四、从”提问技巧”走向”研究系统”</a>
  <ul class="collapse">
  <li><a href="#什么是研究系统" id="toc-什么是研究系统" class="nav-link" data-scroll-target="#什么是研究系统">4.1 什么是”研究系统”</a></li>
  <li><a href="#系统的核心特征" id="toc-系统的核心特征" class="nav-link" data-scroll-target="#系统的核心特征">4.2 系统的核心特征</a></li>
  <li><a href="#ai在系统中的位置" id="toc-ai在系统中的位置" class="nav-link" data-scroll-target="#ai在系统中的位置">4.3 AI在系统中的位置</a></li>
  </ul></li>
  <li><a href="#五建立自己的工作流原则" id="toc-五建立自己的工作流原则" class="nav-link" data-scroll-target="#五建立自己的工作流原则"><span class="header-section-number">4.5</span> 五、建立自己的工作流原则</a>
  <ul class="collapse">
  <li><a href="#任务拆解原则" id="toc-任务拆解原则" class="nav-link" data-scroll-target="#任务拆解原则">5.1 任务拆解原则</a></li>
  <li><a href="#层级输出原则" id="toc-层级输出原则" class="nav-link" data-scroll-target="#层级输出原则">5.2 层级输出原则</a></li>
  <li><a href="#验证机制原则" id="toc-验证机制原则" class="nav-link" data-scroll-target="#验证机制原则">5.3 验证机制原则</a></li>
  <li><a href="#版本记录原则" id="toc-版本记录原则" class="nav-link" data-scroll-target="#版本记录原则">5.4 版本记录原则</a></li>
  <li><a href="#边界意识原则" id="toc-边界意识原则" class="nav-link" data-scroll-target="#边界意识原则">5.5 边界意识原则</a></li>
  </ul></li>
  <li><a href="#六一个完整的例子" id="toc-六一个完整的例子" class="nav-link" data-scroll-target="#六一个完整的例子"><span class="header-section-number">4.6</span> 六、一个完整的例子</a>
  <ul class="collapse">
  <li><a href="#没有系统的做法" id="toc-没有系统的做法" class="nav-link" data-scroll-target="#没有系统的做法">6.1 没有系统的做法</a></li>
  <li><a href="#有系统的做法" id="toc-有系统的做法" class="nav-link" data-scroll-target="#有系统的做法">6.2 有系统的做法</a></li>
  <li><a href="#两种做法的对比" id="toc-两种做法的对比" class="nav-link" data-scroll-target="#两种做法的对比">6.3 两种做法的对比</a></li>
  </ul></li>
  <li><a href="#七写在最后" id="toc-七写在最后" class="nav-link" data-scroll-target="#七写在最后"><span class="header-section-number">4.7</span> 七、写在最后</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/yuzhangsjtu/AAAR/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">第3章 提示词不是方法论</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="一一场关于提示词的迷信" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="一一场关于提示词的迷信"><span class="header-section-number">4.1</span> 一、一场关于提示词的迷信</h2>
<p>2024年春天，我参加了一个AI辅助科研的工作坊。主讲人是一位在社交媒体上颇有影响力的”AI效率专家”，他用了整整两个小时讲解”学术研究的终极提示词模板”。</p>
<p>他的演示确实令人印象深刻：输入一个精心设计的提示词，模型就能输出结构完整的文献综述框架；换一个模板，就能生成看起来专业的研究假设；再换一个，还能产出像模像样的方法论描述。现场的研究生们兴奋地拍照记录，仿佛找到了学术写作的捷径。</p>
<p>但当我仔细审视那些输出时，一种熟悉的不安感涌上心头。那些文献综述框架虽然结构漂亮，但核心论点是空洞的；那些研究假设虽然表述规范，但缺乏对真实研究问题的深入理解；那些方法论描述虽然术语正确，但与具体研究场景脱节。</p>
<p>更让我担忧的是提问环节。一位博士生问：“我的研究是关于社交媒体对青少年心理健康的影响，能不能给我一个更具体的提示词？”主讲人的回答是：“你可以在我的模板里把’研究主题’替换成你的具体领域就行了。”</p>
<p>这个回答让我意识到，我们正在见证一场关于提示词的集体迷信。人们把提示词当成了某种魔法咒语——只要念对了咒语，研究的难题就会迎刃而解。但真正的问题是：如果研究者本身不清楚自己要研究什么、为什么研究、如何研究，再精妙的提示词也只能产出精致的空壳。</p>
</section>
<section id="二提示词能做什么不能做什么" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="二提示词能做什么不能做什么"><span class="header-section-number">4.2</span> 二、提示词能做什么，不能做什么</h2>
<p>让我们先诚实地面对提示词的能力边界。</p>
<section id="提示词确实有用" class="level3">
<h3 class="anchored" data-anchor-id="提示词确实有用">2.1 提示词确实有用</h3>
<p>我不是在说提示词毫无价值。恰恰相反，好的提示词确实能显著提升AI输出的质量。它的作用主要体现在三个方面。</p>
<p><strong>第一，约束输出格式。</strong> 如果你需要模型输出一个表格、一份大纲、或者按照特定结构组织的文本，提示词可以明确这些要求。比如”请以markdown表格形式呈现，包含作者、年份、主要发现、方法论四列”——这种格式约束是有效的，因为它本质上是在给模型一个模板。</p>
<p><strong>第二，设定角色与语境。</strong> 告诉模型”你是一位熟悉社会科学方法论的研究者”或”请以学术论文的语言风格回答”，可以帮助模型调整输出的语气和专业程度。这类似于告诉一个通才”现在请用专家的方式来回答”——虽然不能让通才变成真正的专家，但至少能让回答更像是专家会说的话。</p>
<p><strong>第三，分解复杂任务。</strong> 把一个大问题拆成多个小问题，每次只让模型处理一个环节，这确实能提高输出质量。比如先让模型”列出这篇论文的核心论点”，再让它”分析每个论点的证据支撑”，最后让它”评估整体论证的逻辑强度”——这种分步处理比一次性要求”请全面分析这篇论文”效果更好。</p>
<p>这三种作用是真实的，也是值得学习的。问题在于，很多提示词教程把这些基本技巧包装成了某种神秘的”prompt engineering”，仿佛只要掌握了正确的咒语，就能解锁AI的隐藏能力。</p>
</section>
<section id="提示词不能做什么" class="level3">
<h3 class="anchored" data-anchor-id="提示词不能做什么">2.2 提示词不能做什么</h3>
<p>更重要的是认识到提示词的边界。有些东西是再好的提示词也无法弥补的。</p>
<p><strong>第一，提示词无法提供研究者自己没有的判断力。</strong> 如果你不知道什么是好的研究问题，提示词不会帮你识别出好的研究问题。如果你不理解某个理论框架的核心逻辑，提示词不会让模型的解释变得对你有意义。AI可以生成看起来像是好问题、好框架的东西，但判断它们是否真的好，仍然需要研究者自己的专业素养。</p>
<p>我见过太多这样的情况：研究生用提示词生成了一堆”研究问题选项”，然后问导师”您觉得哪个好”。这个问题本身就暴露了问题所在——如果你需要别人来判断哪个研究问题更好，那么使用提示词生成这些问题并没有让你在研究能力上有任何进步。</p>
<p><strong>第二，提示词无法保证输出的正确性。</strong> 无论你的提示词写得多么精确，模型仍然可能产生幻觉、犯事实错误、或者给出逻辑上有漏洞的论证。很多提示词模板声称能”减少幻觉”或”提高准确性”，但这些说法大多缺乏严格验证。即使某个提示词在特定场景下确实降低了错误率，你也无法事先知道当前这次输出是否属于那”降低的”部分还是”剩余的”错误部分。</p>
<p><strong>第三，提示词无法替代研究过程本身。</strong> 学术研究不是输入问题、输出答案的过程。它涉及反复的阅读与思考、假设的形成与修正、数据的收集与分析、论证的构建与检验。这些过程需要时间，需要投入，需要走弯路然后纠正方向。提示词可以在某些环节提供辅助，但它无法压缩研究过程本身所需要的认知劳动。</p>
<p>有一次，一位学生得意地告诉我，他用一个精心设计的提示词，让ChatGPT”帮他完成了整个文献综述”。我让他随机挑选其中引用的三篇论文，说说每篇论文的核心贡献和方法论特点。他答不上来。这不是因为提示词不够好，而是因为提示词从根本上不可能替代真正阅读和理解文献的过程。</p>
</section>
<section id="核心区分流程辅助-vs.-判断替代" class="level3">
<h3 class="anchored" data-anchor-id="核心区分流程辅助-vs.-判断替代">2.3 核心区分：流程辅助 vs.&nbsp;判断替代</h3>
<p>理解提示词的一个关键是区分两类不同的需求：流程辅助和判断替代。</p>
<p><strong>流程辅助</strong>指的是那些规则明确、可重复、不需要太多专业判断的任务。比如：把一份英文摘要翻译成中文，按照特定格式整理参考文献，从一段文本中提取关键词，把会议记录整理成结构化的要点。这些任务的”正确答案”相对客观，可以被验证，而且验证的成本较低。在这类任务上，提示词确实能发挥显著作用。</p>
<p><strong>判断替代</strong>指的是那些需要专业知识、涉及价值判断、或者依赖语境理解的任务。比如：评估一个研究假设是否有价值，判断一篇论文的方法论是否合理，决定某个论点是否站得住脚，选择研究设计中的关键参数。这些任务没有”标准答案”，正确性高度依赖于研究者的专业素养和对具体情境的理解。在这类任务上，提示词能做的非常有限——它可以让模型输出”像”是专业判断的东西，但不能保证那真的是正确的判断。</p>
<p>很多对提示词的误解，源于没有认清这个区分。人们把在”流程辅助”任务上看到的效果，错误地外推到了”判断替代”任务上。他们想：既然提示词能让翻译质量提高那么多，那应该也能让研究设计的质量提高吧？但这两类任务有本质区别。</p>
</section>
</section>
<section id="三为什么提示词被过度神化" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="三为什么提示词被过度神化"><span class="header-section-number">4.3</span> 三、为什么提示词被过度神化</h2>
<p>既然提示词的边界如此明显，为什么关于它的迷信如此流行？我认为有几个原因。</p>
<section id="简单问题的诱惑" class="level3">
<h3 class="anchored" data-anchor-id="简单问题的诱惑">3.1 简单问题的诱惑</h3>
<p>人类天生偏好简单的解决方案。面对”如何做好学术研究”这个复杂问题，“学会写好提示词”是一个极具吸引力的答案——它具体、可操作、而且见效快。相比之下，“深入理解你的研究领域”“培养批判性思维”“在反复试错中积累经验”这些答案虽然更接近真相，但听起来既抽象又费力。</p>
<p>提示词模板满足了人们对”速成攻略”的渴望。收藏一个”万能提示词”比花三个月读透一个研究领域的文献要轻松得多。更诱人的是，模型确实会给出看起来不错的回应——它不会说”这个问题太复杂，我回答不了”，它会给你一个结构完整、语言流畅的输出。这种即时的正反馈强化了”提示词就是答案”的错觉。</p>
</section>
<section id="商业利益的驱动" class="level3">
<h3 class="anchored" data-anchor-id="商业利益的驱动">3.2 商业利益的驱动</h3>
<p>我们不能忽视围绕”提示词工程”已经形成的商业生态。有人卖课程，有人卖模板，有人靠分享”提示词技巧”积累社交媒体影响力。这些商业模式都依赖于一个前提：提示词是一种需要专门学习的技能，而且学会了就能获得显著回报。</p>
<p>这不是说所有提示词教程都是骗人的。有些确实提供了有价值的思路和技巧。但商业激励确实会导致系统性的夸大。教你”这个提示词能让你的论文写作效率提升300%“比教你”这个技巧能在某些特定场景下略微改善输出质量”更容易吸引点击和付费。</p>
</section>
<section id="对ai能力的误解" class="level3">
<h3 class="anchored" data-anchor-id="对ai能力的误解">3.3 对AI能力的误解</h3>
<p>很多对提示词的迷信，根源在于对大语言模型本身能力的误解。</p>
<p>有一种常见的心智模型是：AI”知道”很多东西，问题只是如何”问对问题”把这些知识引出来。按照这个逻辑，提示词就像是打开宝库的钥匙——只要找到正确的钥匙，就能获取里面的宝藏。</p>
<p>但这个心智模型是错误的。大语言模型不是一个装满知识等待被提取的容器，而是一个被训练来预测”给定前文，下一个词最可能是什么”的系统。它在生成输出时，并没有在”搜索”某个内部数据库，而是在基于统计规律”构建”一个最可能的延续。</p>
<p>这意味着什么？意味着模型的输出质量不仅取决于你怎么问，更取决于它在训练时见过什么样的数据、这些数据的质量和偏向是什么、以及你的问题在多大程度上落在它的”能力范围”之内。改变提示词可以影响输出，但无法突破这些更根本的限制。</p>
</section>
<section id="可观察性偏差" class="level3">
<h3 class="anchored" data-anchor-id="可观察性偏差">3.4 可观察性偏差</h3>
<p>还有一个更微妙的原因：提示词是可见的，而研究能力是不可见的。</p>
<p>当一个研究生使用同样的提示词却得到比你更好的结果时，你看不到的是：他在使用提示词之前已经花了多少时间理解那个研究领域，他在评估输出时运用了怎样的专业判断，他如何在多轮对话中逐步修正和深化最初的输出。你能看到的只是那个”提示词”，于是你会误以为差别在于提示词本身。</p>
<p>真正起作用的往往是那些不可见的东西：对问题的清晰理解、对质量的准确判断、对输出的批判性评估。但这些东西难以传授、难以包装、也难以售卖。提示词之所以成为焦点，部分原因是它恰好是整个过程中最容易观察和复制的部分。</p>
</section>
</section>
<section id="四从提问技巧走向研究系统" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="四从提问技巧走向研究系统"><span class="header-section-number">4.4</span> 四、从”提问技巧”走向”研究系统”</h2>
<p>如果提示词不是答案，那什么才是？我的建议是：把注意力从”如何问好一个问题”转向”如何构建一个可靠的研究系统”。</p>
<section id="什么是研究系统" class="level3">
<h3 class="anchored" data-anchor-id="什么是研究系统">4.1 什么是”研究系统”</h3>
<p>所谓研究系统，是指一套可重复、可检验、可追溯的工作流程，它规定了：</p>
<ul>
<li><strong>输入什么材料</strong>：你用什么数据、什么文献、什么信息作为起点</li>
<li><strong>执行什么任务</strong>：你要完成哪些具体的处理和分析步骤</li>
<li><strong>如何校验输出</strong>：你用什么标准和方法来检查结果的质量</li>
<li><strong>怎样记录过程</strong>：你如何保留足够的信息以便日后追溯和复现</li>
</ul>
<p>注意，这个定义中没有提到”提示词”。提示词可以是这个系统的一部分，但只是很小的一部分。系统的核心不在于你和AI说了什么话，而在于这些对话嵌入在怎样的工作流程中。</p>
<p>让我用一个具体例子来说明。假设你的任务是”整理某个领域的核心文献”。</p>
<p><strong>没有系统的做法</strong>是：打开ChatGPT，输入”请推荐关于XX领域的重要文献”，然后把输出保存下来。这个做法的问题是显而易见的：你不知道模型推荐这些文献的依据是什么，你无法验证这些推荐的质量，一个月后你可能完全记不起这份列表是怎么来的。</p>
<p><strong>有系统的做法</strong>可能是这样的：</p>
<ol type="1">
<li><p>首先，确定文献来源（比如Web of Science、Scopus、Google Scholar），并记录检索策略（关键词、时间范围、筛选条件）。</p></li>
<li><p>其次，下载初筛结果（比如100篇论文的题目和摘要），存档为原始数据。</p></li>
<li><p>然后，用AI辅助进行第一轮分类：把论文按主题聚类，识别高频引用的关键作者和概念。在这个步骤中，你可以使用提示词，但关键是记录你使用的具体提示词和模型版本。</p></li>
<li><p>接着，人工审核AI的分类结果，修正错误，补充遗漏。这个步骤不能省略，因为它是你真正建立对领域理解的过程。</p></li>
<li><p>然后，针对每个主题聚类，精读3-5篇代表性论文，记录你自己的理解和评价。</p></li>
<li><p>最后，整理输出一份文献地图，包括主要主题、核心论文、关键争议、研究空白。</p></li>
<li><p>全程保留版本记录：每次修改都有时间戳，可以追溯任何结论是怎么得出的。</p></li>
</ol>
<p>在这个系统中，AI确实参与了某些环节（比如第3步的初步分类），但它的角色是明确的、有限的、可审计的。更重要的是，即使完全不用AI，这个系统依然成立——AI只是让某些步骤更高效，但没有改变系统的基本结构。</p>
</section>
<section id="系统的核心特征" class="level3">
<h3 class="anchored" data-anchor-id="系统的核心特征">4.2 系统的核心特征</h3>
<p>一个好的研究系统应该具备几个核心特征。</p>
<p><strong>可重复</strong>：如果你或你的同事遵循同样的流程，应该能够得到相似（虽然不必完全相同）的结果。这意味着流程需要足够具体，关键参数需要被记录，随机性需要被控制或至少被记录。</p>
<p><strong>可检验</strong>：系统的每个环节都应该有某种质量检查的方式。不是等到最后才发现问题，而是在过程中就能发现和纠正问题。比如，AI生成的文献分类应该通过抽查来验证，而不是默认接受。</p>
<p><strong>可追溯</strong>：事后应该能够回答”这个结论是怎么得出的”。这需要充分的记录：使用了什么数据，经过了哪些处理，做了哪些决策，依据是什么。当AI参与时，这一点尤其重要——你需要记录使用的模型、版本、提示词、输出。</p>
<p><strong>容错</strong>：系统应该假设会出错，并在设计中考虑如何发现和纠正错误。冗余检查、交叉验证、人工复核——这些机制不是”额外工作”，而是保证质量的必要投入。</p>
</section>
<section id="ai在系统中的位置" class="level3">
<h3 class="anchored" data-anchor-id="ai在系统中的位置">4.3 AI在系统中的位置</h3>
<p>在一个设计良好的研究系统中，AI的位置应该是明确的和受限的。</p>
<p><strong>明确</strong>意味着：你清楚AI在哪些环节参与、执行什么任务、产出什么结果。不是”我用AI帮忙做了一些事情”，而是”AI在步骤3执行了初步分类，在步骤5协助了文本润色”。</p>
<p><strong>受限</strong>意味着：AI不应该出现在那些需要核心判断的关键节点上，或者即使出现也必须有严格的人工复核。识别哪些节点是”关键的”，本身就是设计系统的重要工作。</p>
<p>一个有用的问题是：如果AI在这个环节犯了错，后果是什么？如果后果严重且难以通过后续步骤发现，那这个环节就需要额外的保护——要么不使用AI，要么必须有独立的验证机制。</p>
<p>另一个有用的问题是：这个环节的质量，我能通过什么方式检验？如果你无法独立验证AI的输出质量（比如因为你自己不具备相关知识），那就不应该在这个环节依赖AI——因为你没有办法知道它是否做对了。</p>
</section>
</section>
<section id="五建立自己的工作流原则" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="五建立自己的工作流原则"><span class="header-section-number">4.5</span> 五、建立自己的工作流原则</h2>
<p>基于以上讨论，我想提出几个构建AI辅助研究工作流的核心原则。这些原则不是具体的提示词模板，而是设计工作流程时应该遵循的指导思想。</p>
<section id="任务拆解原则" class="level3">
<h3 class="anchored" data-anchor-id="任务拆解原则">5.1 任务拆解原则</h3>
<p><strong>核心思想</strong>：把大任务分解成小任务，把模糊任务转化为具体任务。</p>
<p>大语言模型在处理边界清晰的小任务时表现更好。“帮我写一篇关于气候变化政策的综述”是一个糟糕的任务描述，因为它包含太多隐含的子任务：确定综述范围、检索相关文献、筛选核心论文、归纳主要观点、识别研究空白、组织成文……每一个子任务都有自己的复杂性。</p>
<p>更好的做法是显式地拆解：</p>
<ul>
<li>任务1：明确综述的具体问题（关于气候变化政策的什么？碳税的经济效应？还是国际协调机制的有效性？）</li>
<li>任务2：确定检索策略（在哪些数据库检索？用什么关键词？时间范围是多少？）</li>
<li>任务3：初步筛选（根据题目和摘要，排除明显不相关的文献）</li>
<li>任务4：深入阅读核心文献（精读20-30篇最相关的论文）</li>
<li>任务5：归纳和综合（提取主要发现，识别共识和争议）</li>
<li>……</li>
</ul>
<p>在这个拆解中，有些任务适合AI辅助（比如任务3的初步筛选），有些则必须由人类主导（比如任务1的问题界定和任务4的深入阅读）。拆解本身就是在明确AI的角色边界。</p>
<p><strong>实践建议</strong>：在使用AI之前，先用纸和笔（或者简单的文本文件）把你的任务拆解成尽可能小的单元。问自己：这个单元的输入是什么？期望的输出是什么？我如何判断输出的质量？</p>
</section>
<section id="层级输出原则" class="level3">
<h3 class="anchored" data-anchor-id="层级输出原则">5.2 层级输出原则</h3>
<p><strong>核心思想</strong>：不要期望一次性得到完美输出，而是通过多轮迭代逐步精化。</p>
<p>很多人使用AI的方式是：输入一个提示词，得到一个输出，如果不满意就换一个提示词再试。这种方式把每次交互都当作独立的事件，没有利用对话的累积性。</p>
<p>更有效的方式是层级式的：</p>
<ul>
<li><strong>第一层：粗略轮廓。</strong> 先让AI给出一个粗略的框架或方向。这个阶段的目标不是获得可用的输出，而是快速探索可能性。</li>
<li><strong>第二层：细化某个方向。</strong> 在粗略轮廓中选择一个值得深入的方向，让AI进一步展开。这时可以提供更多具体信息和约束条件。</li>
<li><strong>第三层：具体化和验证。</strong> 对细化后的内容进行具体化，同时开始验证关键信息的准确性。这个阶段经常需要跳出AI对话，去查阅原始资料。</li>
<li><strong>第四层：整合和润色。</strong> 把经过验证的内容整合成最终输出，进行语言和格式上的润色。</li>
</ul>
<p>这个过程不是线性的。你可能在第三层发现第一层的方向选错了，需要回退重来。但层级化的思路保证了每一步都有明确的目标，错误能够被较早发现。</p>
<p><strong>实践建议</strong>：在每一层结束时，暂停下来问自己：这个输出是否足够准确，值得在它的基础上继续深入？如果你发现自己在第三层才发现第一层就有根本性问题，下次就要考虑在第一层投入更多验证工作。</p>
</section>
<section id="验证机制原则" class="level3">
<h3 class="anchored" data-anchor-id="验证机制原则">5.3 验证机制原则</h3>
<p><strong>核心思想</strong>：任何AI输出都需要验证，验证的力度应该与错误的后果成正比。</p>
<p>验证不是可选的附加步骤，而是使用AI的必要组成部分。问题是验证需要成本，所以需要根据风险来分配验证资源。</p>
<p><strong>低风险任务</strong>（错误易发现，后果可逆，成本低）：可以采用抽查式验证。比如AI帮你整理了一份100条的引用列表，你可以随机抽查10条来判断整体质量。</p>
<p><strong>中风险任务</strong>（错误较隐蔽，后果有影响，成本中等）：需要系统性验证。比如AI帮你总结了10篇论文的核心论点，你应该每一篇都回到原文核对，确保概括准确。</p>
<p><strong>高风险任务</strong>（错误难发现，后果严重，成本高）：需要独立验证。比如AI给出了某个统计方法的解释，你应该查阅教科书或权威资料独立确认，而不是仅仅让同一个AI”再解释一遍”。</p>
<p>有一种常见的错误是用AI来验证AI的输出——让同一个模型检查自己之前的回答，或者换一个提示词让它”确认”之前的结论。这种做法几乎没有验证价值，因为模型的偏差是系统性的，它不会通过重复访问而消失。</p>
<p><strong>实践建议</strong>：在开始一个任务之前，先问自己：如果AI在这里犯错，我会怎么发现？如果你答不上来，说明这个任务可能不适合交给AI，或者你需要先设计一个验证机制。</p>
</section>
<section id="版本记录原则" class="level3">
<h3 class="anchored" data-anchor-id="版本记录原则">5.4 版本记录原则</h3>
<p><strong>核心思想</strong>：保留足够的信息，使得任何结论都可以追溯其来源。</p>
<p>这个原则在传统研究方法论中已经很重要（记录数据来源、分析代码、决策理由），在AI辅助研究中更加重要，因为AI增加了一个不透明的环节。</p>
<p>需要记录的信息包括：</p>
<ul>
<li><strong>模型信息</strong>：使用的模型名称和版本（比如GPT-4-turbo-2024-04-09），使用的参数设置（比如temperature）</li>
<li><strong>输入信息</strong>：完整的提示词，提供给模型的上下文材料</li>
<li><strong>输出信息</strong>：模型的完整输出（不仅仅是你使用的部分）</li>
<li><strong>处理信息</strong>：你对输出进行了哪些修改、筛选、整合</li>
<li><strong>验证信息</strong>：你进行了哪些验证，验证的结果是什么</li>
</ul>
<p>这听起来像是大量额外工作，但实际上可以通过工具和习惯来简化。很多AI对话工具允许导出完整历史；你可以建立标准化的文件夹结构来组织这些记录；关键决策点可以用简单的笔记来记录理由。</p>
<p><strong>实践建议</strong>：至少做到这一点——每次使用AI完成一个重要任务，事后能够回答”这个结论是基于什么输入、经过什么处理、做过什么验证”。如果你发现自己答不上来，说明记录工作需要加强。</p>
</section>
<section id="边界意识原则" class="level3">
<h3 class="anchored" data-anchor-id="边界意识原则">5.5 边界意识原则</h3>
<p><strong>核心思想</strong>：清晰地认识到哪些任务适合AI辅助，哪些不适合。</p>
<p>这个原则是前面所有原则的基础。如果你不知道AI的能力边界在哪里，就无法正确地设计任务拆解、输出层级、验证机制。</p>
<p>一些经验性的指导：</p>
<p><strong>适合AI辅助的任务特征</strong>： - 规则明确，“正确答案”相对客观 - 验证成本低（你可以较容易地检查输出质量） - 错误后果可控（即使出错也可以补救） - 任务可分解，每个子任务边界清晰</p>
<p><strong>不适合AI辅助的任务特征</strong>： - 需要深度专业判断 - 你自己无法独立验证输出质量 - 错误后果严重且难以察觉 - 任务高度依赖特定语境和隐性知识</p>
<p>当然，这不是非黑即白的分类。很多任务介于两者之间，需要具体分析。关键是培养这种分析习惯：在把任务交给AI之前，先思考这个任务的特征，评估AI可能带来的价值和风险。</p>
<p><strong>实践建议</strong>：保持一个”AI使用日志”，记录你使用AI的场景、效果、遇到的问题。一段时间后，你会对自己的使用模式有更清晰的认识，知道哪些场景值得继续探索，哪些应该避免。</p>
</section>
</section>
<section id="六一个完整的例子" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="六一个完整的例子"><span class="header-section-number">4.6</span> 六、一个完整的例子</h2>
<p>让我用一个具体的例子来说明如何应用这些原则。假设你是一位社会科学研究生，你的导师让你”调研一下最近五年关于算法歧视的实证研究”。</p>
<section id="没有系统的做法" class="level3">
<h3 class="anchored" data-anchor-id="没有系统的做法">6.1 没有系统的做法</h3>
<p>你打开ChatGPT，输入：“请帮我整理最近五年关于算法歧视的实证研究，包括主要发现和方法论。”</p>
<p>模型给出了一份看起来不错的列表，包含了十几项研究的简要描述。你把这份列表整理一下，交给了导师。</p>
<p>两周后，导师问你：“你提到的那个ProPublica关于COMPAS的研究，他们具体的分析方法是什么？有什么局限性？”你答不上来，因为你从来没有读过那篇原始报告。</p>
</section>
<section id="有系统的做法" class="level3">
<h3 class="anchored" data-anchor-id="有系统的做法">6.2 有系统的做法</h3>
<p><strong>第一步：明确任务边界（任务拆解）</strong></p>
<p>你首先问自己几个问题： - “最近五年”是指哪个时间范围？（确定：2019-2024） - “算法歧视”的定义是什么？包括哪些类型？（确定：主要聚焦于机器学习算法在信贷、招聘、刑事司法等领域的歧视性结果） - “实证研究”是指什么？（确定：包括真实数据分析、审计研究、实验研究，不包括纯理论论文） - 导师期待的产出是什么？（确定：一份综述报告，约3000字，需要包括研究方法的比较分析）</p>
<p><strong>第二步：设计检索策略</strong></p>
<p>你决定从两个来源检索文献： - 学术数据库：Web of Science，使用关键词”algorithmic bias” OR “algorithmic discrimination” AND “empirical” - 补充来源：Google Scholar，用于捕捉可能不在WoS中的跨学科研究和工作论文</p>
<p>你记录了检索时间、检索词、检索条件、结果数量。</p>
<p><strong>第三步：初步筛选（AI辅助）</strong></p>
<p>从检索中获得约200篇文献的题目和摘要。你把这些导出为一个文件，然后使用AI进行第一轮筛选。</p>
<p>提示词：“以下是200篇关于算法歧视的论文摘要。请帮我识别其中属于’实证研究’的论文（即使用真实数据或实验方法研究算法歧视现象的研究），并按照研究领域（信贷、招聘、刑事司法、医疗、其他）分类。”</p>
<p>AI给出了一个分类列表，标注了约80篇可能是实证研究的论文。</p>
<p><strong>第四步：验证和调整（验证机制）</strong></p>
<p>你随机抽取10篇AI标注为”实证研究”的论文，快速浏览摘要验证分类是否正确。发现8篇分类准确，2篇其实是综述性文章被误标。</p>
<p>你又抽取5篇AI标注为”非实证研究”的论文，检查是否有遗漏。发现1篇其实是实证研究但被遗漏了。</p>
<p>基于这个抽查结果，你估计AI的分类大致可靠，但存在约20%的错误率。你决定对所有80篇”实证研究”的摘要进行人工快速审核，最终确定约65篇进入下一轮。</p>
<p><strong>第五步：深入阅读（不使用AI）</strong></p>
<p>你从65篇中选择20篇代表性论文进行精读。选择标准包括：高被引、方法论创新、涵盖不同领域。</p>
<p>这个步骤没有使用AI。你阅读每篇论文的全文，记录研究问题、数据来源、分析方法、主要发现、局限性。这是建立真正理解的过程，不可压缩。</p>
<p><strong>第六步：归纳综合</strong></p>
<p>你基于深度阅读的笔记，开始归纳主要发现和方法论趋势。在这个阶段，你可以用AI辅助整理思路：</p>
<p>“我阅读了20篇关于算法歧视的实证研究，以下是我的笔记摘要。请帮我识别这些研究在方法论上的共同点和差异，以及主要发现的共识和争议。”</p>
<p>AI给出了一个初步的综合，你在此基础上修改和补充，加入你自己的分析和判断。</p>
<p><strong>第七步：撰写报告（迭代润色）</strong></p>
<p>你先手写一个粗略的提纲，然后逐节展开写作。写完初稿后，可以用AI帮助检查语言流畅度、识别论述空白。</p>
<p>但最终的判断——这篇综述是否准确反映了文献的实际状况——只有你自己能做出，因为只有你真正读过那些原始论文。</p>
<p><strong>第八步：保留记录（版本记录）</strong></p>
<p>整个过程中，你保留了： - 检索记录（日期、数据库、检索词、结果数量） - 原始文献列表（200篇的题目、摘要、来源） - AI对话记录（每次使用AI的输入和输出） - 阅读笔记（20篇精读论文的详细笔记） - 写作版本（综述报告的多个修订版本）</p>
<p>当导师问你任何问题，你都可以追溯到原始证据。</p>
</section>
<section id="两种做法的对比" class="level3">
<h3 class="anchored" data-anchor-id="两种做法的对比">6.3 两种做法的对比</h3>
<p>两种做法的时间投入差别很大——第二种可能需要两周，第一种可能只需要两小时。但产出的质量完全不同。</p>
<p>更重要的是，第二种做法在过程中建立了真正的理解。你读完那20篇论文后，你对这个领域有了真正的认识，能够参与专业讨论，能够识别新研究的价值和问题。第一种做法什么都没有留下——既没有知识的积累，也没有可追溯的记录。</p>
<p>AI在第二种做法中确实发挥了作用：它帮助你进行了初步分类，节省了大量筛选时间；它帮助你综合笔记，加速了写作过程。但AI的角色是明确的、有限的、受控的。它是研究系统中的一个组件，而不是整个系统的替代品。</p>
</section>
</section>
<section id="七写在最后" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="七写在最后"><span class="header-section-number">4.7</span> 七、写在最后</h2>
<p>让我回到本章开始时那个AI工作坊的场景。</p>
<p>那位主讲人教授的提示词技巧，严格来说并没有错。格式约束、角色设定、任务分解——这些确实是有用的技巧。问题在于，他把这些技巧包装成了某种”终极解决方案”，暗示掌握了这些提示词就能解决学术研究的核心难题。</p>
<p>但学术研究的核心难题——提出有价值的问题、设计可靠的方法、做出准确的判断、构建有说服力的论证——不是任何提示词能够解决的。这些能力需要长期积累，需要深入阅读，需要反复实践，需要失败和纠错。提示词可以在这个过程中提供一些辅助，但它不是捷径，因为根本就没有捷径。</p>
<p>这就是为什么我说”提示词不是方法论”。方法论是关于”如何做好研究”的系统性思考，它涉及研究设计、证据标准、推理规则、质量控制。提示词只是与AI交互的界面，它是技术层面的，而不是方法论层面的。把提示词当作方法论来学习，就像把”如何握笔”当作”如何写好文章”来学习——不是说握笔不重要，但它解决不了写作的真正难题。</p>
<p>我希望这一章能够帮助读者建立一个更健康的与AI的关系。这个关系的核心是：<strong>AI是工具，不是导师；是助手，不是替代；是流程中的一个环节，不是整个流程。</strong></p>
<p>理解了这一点，你就会知道应该把精力放在哪里。不是去收集更多的提示词模板，而是去培养自己的研究能力。不是去追求”一键生成”的幻觉，而是去构建可靠的工作系统。不是去问”有没有更好的提示词”，而是去问”我的研究流程哪里可以改进”。</p>
<p>提示词可以优化，但方法论需要建构。前者是技巧，后者是能力。这本书的目的，正是帮助你从技巧走向能力。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/yuzhangsjtu\.github\.io\/AAAR\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../outline/02-幻觉偏差泄露.html" class="pagination-link" aria-label="第2章 幻觉、偏差、泄露：三类核心风险">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">第2章 幻觉、偏差、泄露：三类核心风险</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../outline/04-信息压缩与文献整理.html" class="pagination-link" aria-label="第4章 信息压缩与文献整理">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">第4章 信息压缩与文献整理</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/yuzhangsjtu/AAAR/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>
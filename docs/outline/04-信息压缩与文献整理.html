<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5&nbsp; 第4章 信息压缩与文献整理 – AAAR：AI加速学术研究的方法论与经验</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../outline/05-结构化表达与写作.html" rel="next">
<link href="../outline/03-提示词不是方法论.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-99913b7803b80b0c1d2b970a25816663.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400;1,700&family=Roboto:ital,wght@0,700;1,300&display=swap');
</style>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
};
</script>


<link rel="stylesheet" href="../css/causal_inference_style.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../outline/04-信息压缩与文献整理.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">第4章 信息压缩与文献整理</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">AAAR：AI加速学术研究的方法论与经验</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/yuzhangsjtu/AAAR" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../aaar-ai-accelerating-academic-research.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/00-序章-为什么写这本书.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">序章｜为什么写这本书</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/01-AI能做什么不能做什么.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">第1章 AI能做什么，不能做什么</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/02-幻觉偏差泄露.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">第2章 幻觉、偏差、泄露：三类核心风险</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/03-提示词不是方法论.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">第3章 提示词不是方法论</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/04-信息压缩与文献整理.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">第4章 信息压缩与文献整理</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/05-结构化表达与写作.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">第5章 结构化表达与写作</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/06-代码与计算能力.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">第6章 代码与计算能力</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/07-知识管理与协作.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">第7章 知识管理与协作</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/08-选题与研究问题.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">第8章 选题与研究问题</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/09-文献与理论构建.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">第9章 文献与理论构建</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/10-数据获取与构造.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">第10章 数据获取与构造</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/11-数据清洗与分析.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">第11章 数据清洗与分析</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/12-写作投稿与传播.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">第12章 写作、投稿与传播</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/13-RA-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">第13章 RA Level：工具层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/14-Supervisor-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">第14章 Supervisor Level：认知协作层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/15-Domain-expert-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">第15章 Domain Expert Level：推理与建模层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/16-Agent-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">第16章 Agent Level：AI作为行动者</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/17-Governance-level.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">第17章 Governance Level：制度与治理层</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/18-终章-AI时代研究者的新能力结构.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">终章｜AI时代研究者的新能力结构</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline/19-附录.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">附录（可选）</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#引言从信息过载到结构化理解" id="toc-引言从信息过载到结构化理解" class="nav-link active" data-scroll-target="#引言从信息过载到结构化理解"><span class="header-section-number">5.1</span> 引言：从信息过载到结构化理解</a></li>
  <li><a href="#一文献筛选与主题聚类" id="toc-一文献筛选与主题聚类" class="nav-link" data-scroll-target="#一文献筛选与主题聚类"><span class="header-section-number">5.2</span> 一、文献筛选与主题聚类</a>
  <ul class="collapse">
  <li><a href="#文献筛选的两阶段模型" id="toc-文献筛选的两阶段模型" class="nav-link" data-scroll-target="#文献筛选的两阶段模型">1.1 文献筛选的两阶段模型</a></li>
  <li><a href="#设计有效的筛选指令" id="toc-设计有效的筛选指令" class="nav-link" data-scroll-target="#设计有效的筛选指令">1.2 设计有效的筛选指令</a></li>
  <li><a href="#主题聚类的策略" id="toc-主题聚类的策略" class="nav-link" data-scroll-target="#主题聚类的策略">1.3 主题聚类的策略</a></li>
  <li><a href="#一个实践案例" id="toc-一个实践案例" class="nav-link" data-scroll-target="#一个实践案例">1.4 一个实践案例</a></li>
  </ul></li>
  <li><a href="#二长上下文模型的正确用法" id="toc-二长上下文模型的正确用法" class="nav-link" data-scroll-target="#二长上下文模型的正确用法"><span class="header-section-number">5.3</span> 二、长上下文模型的正确用法</a>
  <ul class="collapse">
  <li><a href="#长上下文能力的本质与局限" id="toc-长上下文能力的本质与局限" class="nav-link" data-scroll-target="#长上下文能力的本质与局限">2.1 长上下文能力的本质与局限</a></li>
  <li><a href="#分层处理策略" id="toc-分层处理策略" class="nav-link" data-scroll-target="#分层处理策略">2.2 分层处理策略</a></li>
  <li><a href="#输入质量的重要性" id="toc-输入质量的重要性" class="nav-link" data-scroll-target="#输入质量的重要性">2.3 输入质量的重要性</a></li>
  <li><a href="#输出设计与质量控制" id="toc-输出设计与质量控制" class="nav-link" data-scroll-target="#输出设计与质量控制">2.4 输出设计与质量控制</a></li>
  <li><a href="#一个错误使用的案例" id="toc-一个错误使用的案例" class="nav-link" data-scroll-target="#一个错误使用的案例">2.5 一个错误使用的案例</a></li>
  </ul></li>
  <li><a href="#三可信综述生成引用与验证" id="toc-三可信综述生成引用与验证" class="nav-link" data-scroll-target="#三可信综述生成引用与验证"><span class="header-section-number">5.4</span> 三、可信综述生成：引用与验证</a>
  <ul class="collapse">
  <li><a href="#为什么综述生成是高风险任务" id="toc-为什么综述生成是高风险任务" class="nav-link" data-scroll-target="#为什么综述生成是高风险任务">3.1 为什么综述生成是高风险任务</a></li>
  <li><a href="#ai在综述生成中的适当角色" id="toc-ai在综述生成中的适当角色" class="nav-link" data-scroll-target="#ai在综述生成中的适当角色">3.2 AI在综述生成中的适当角色</a></li>
  <li><a href="#引用验证的系统方法" id="toc-引用验证的系统方法" class="nav-link" data-scroll-target="#引用验证的系统方法">3.3 引用验证的系统方法</a></li>
  <li><a href="#建立可追溯的证据链" id="toc-建立可追溯的证据链" class="nav-link" data-scroll-target="#建立可追溯的证据链">3.4 建立可追溯的证据链</a></li>
  <li><a href="#ai辅助综述的披露与伦理" id="toc-ai辅助综述的披露与伦理" class="nav-link" data-scroll-target="#ai辅助综述的披露与伦理">3.5 AI辅助综述的披露与伦理</a></li>
  </ul></li>
  <li><a href="#四从工具到能力信息素养的新维度" id="toc-四从工具到能力信息素养的新维度" class="nav-link" data-scroll-target="#四从工具到能力信息素养的新维度"><span class="header-section-number">5.5</span> 四、从工具到能力：信息素养的新维度</a>
  <ul class="collapse">
  <li><a href="#信息压缩作为研究者的核心能力" id="toc-信息压缩作为研究者的核心能力" class="nav-link" data-scroll-target="#信息压缩作为研究者的核心能力">4.1 信息压缩作为研究者的核心能力</a></li>
  <li><a href="#人机协作的最优配置" id="toc-人机协作的最优配置" class="nav-link" data-scroll-target="#人机协作的最优配置">4.2 人机协作的最优配置</a></li>
  <li><a href="#未来研究者的信息素养" id="toc-未来研究者的信息素养" class="nav-link" data-scroll-target="#未来研究者的信息素养">4.3 未来研究者的信息素养</a></li>
  </ul></li>
  <li><a href="#结语" id="toc-结语" class="nav-link" data-scroll-target="#结语"><span class="header-section-number">5.6</span> 结语</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/yuzhangsjtu/AAAR/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">第4章 信息压缩与文献整理</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="引言从信息过载到结构化理解" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="引言从信息过载到结构化理解"><span class="header-section-number">5.1</span> 引言：从信息过载到结构化理解</h2>
<p>学术研究者面临的核心挑战之一是信息过载。一个活跃的研究领域每年可能产出数千篇论文，而研究者的阅读时间是有限的。传统的文献整理方法——逐篇阅读、手工分类、人工综合——在信息爆炸的时代显得力不从心。大语言模型的出现为这一困境提供了新的可能性：它们能够快速处理大量文本，提取关键信息，生成结构化的摘要和分类。</p>
<p>然而，这种可能性伴随着显著的风险。模型可能遗漏重要文献，可能错误归纳论点，可能生成不存在的引用。如果研究者不加辨别地接受AI的输出，信息压缩就会变成信息扭曲。本章的目标是探讨如何在文献整理工作中有效利用AI的信息压缩能力，同时建立必要的质量保障机制。</p>
<p>本章将依次讨论三个核心议题：文献筛选与主题聚类的方法，长上下文模型的正确使用方式，以及可信综述生成的验证策略。贯穿这些讨论的核心原则是：AI的输出应被视为”索引”而非”结论”，是研究过程的起点而非终点。</p>
</section>
<section id="一文献筛选与主题聚类" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="一文献筛选与主题聚类"><span class="header-section-number">5.2</span> 一、文献筛选与主题聚类</h2>
<section id="文献筛选的两阶段模型" class="level3">
<h3 class="anchored" data-anchor-id="文献筛选的两阶段模型">1.1 文献筛选的两阶段模型</h3>
<p>文献筛选是任何研究项目的基础工作。传统的筛选流程通常包括：确定检索策略、执行数据库检索、根据题目和摘要进行初筛、根据全文进行精筛。这个流程的瓶颈在于初筛阶段——面对数百甚至数千条检索结果，研究者需要逐条判断相关性，这是一项耗时且认知负担沉重的工作。</p>
<p>AI辅助可以显著提高初筛阶段的效率，但前提是研究者理解这种辅助的性质和边界。我建议采用”两阶段模型”来组织AI辅助的文献筛选工作。</p>
<p>第一阶段是AI辅助的粗筛。在这个阶段，研究者将检索结果（通常是题目和摘要的列表）提交给模型，要求模型根据预设的纳入和排除标准进行初步分类。模型的任务是识别”明显相关”“明显不相关”和”需要进一步判断”三类文献。这个阶段的目标不是获得最终的筛选结果，而是快速缩小需要人工审阅的范围。</p>
<p>第二阶段是人工复核与精筛。研究者对AI标记为”明显相关”和”需要进一步判断”的文献进行人工审阅，做出最终的纳入决策。同时，研究者应当抽样检查AI标记为”明显不相关”的文献，评估AI的假阴性率（即被错误排除的相关文献比例）。如果假阴性率过高，需要调整第一阶段的指令或标准。</p>
<p>这个两阶段模型的核心逻辑是：AI负责处理”容易”的决策（明显相关或明显不相关的文献），人类负责处理”困难”的决策（边界情况和最终判断）。这种分工既利用了AI的处理速度，又保留了人类的判断权威。</p>
</section>
<section id="设计有效的筛选指令" class="level3">
<h3 class="anchored" data-anchor-id="设计有效的筛选指令">1.2 设计有效的筛选指令</h3>
<p>AI辅助筛选的效果高度依赖于指令的质量。一个有效的筛选指令应当包含以下要素。</p>
<p>首先是明确的研究问题陈述。研究者需要清晰地告诉模型，这次文献检索要回答什么问题。模糊的问题陈述会导致模糊的筛选结果。例如，“关于气候变化的研究”是一个过于宽泛的陈述，而”关于碳税政策对企业减排行为影响的实证研究”则提供了明确的边界。</p>
<p>其次是具体的纳入标准。纳入标准应当是可操作的、可判断的。例如：“纳入标准：（1）研究对象为企业或行业层面的减排行为；（2）研究方法为实证分析（包括定量和定性）；（3）研究涉及碳税或碳定价政策；（4）发表时间为2015年至今。”这些标准使得模型能够对每一篇文献做出相对客观的判断。</p>
<p>第三是明确的排除标准。排除标准帮助模型识别那些表面相关但实际不符合需求的文献。例如：“排除标准：（1）纯理论或模拟研究，无实证数据；（2）研究对象为个人消费者行为而非企业行为；（3）仅讨论碳交易而不涉及碳税；（4）会议摘要、书评、社论等非研究性文献。”</p>
<p>第四是输出格式的规定。研究者应当明确告诉模型如何呈现筛选结果。例如：“请将每篇文献分类为’纳入’‘排除’或’待定’，并简要说明分类理由（一句话）。”结构化的输出便于后续的人工复核和记录。</p>
</section>
<section id="主题聚类的策略" class="level3">
<h3 class="anchored" data-anchor-id="主题聚类的策略">1.3 主题聚类的策略</h3>
<p>主题聚类是文献整理的另一项核心任务。当研究者面对一个新的研究领域时，往往需要首先了解这个领域的主要研究主题、核心争论和知识结构。传统的做法是通过广泛阅读逐步建立这种理解，但这需要大量时间。AI可以帮助研究者快速获得一个初步的领域地图。</p>
<p>有效的主题聚类需要遵循几个原则。</p>
<p>第一个原则是层次化聚类。不要试图一次性获得一个完美的分类体系，而是采用从粗到细的迭代策略。第一轮聚类可以识别3-5个大的主题领域；第二轮在每个大主题下进一步细分子主题；第三轮识别子主题之间的交叉和联系。这种层次化的方法既便于理解，也便于发现聚类中的问题。</p>
<p>第二个原则是多维度聚类。同一批文献可以从不同维度进行分类。例如，按研究主题分类、按研究方法分类、按研究对象分类、按理论框架分类。不同的分类维度揭示领域的不同面向。研究者应当根据自己的研究需求选择最相关的分类维度，或者综合使用多个维度。</p>
<p>第三个原则是保留边界案例。在聚类过程中，总会遇到难以归类的文献——它们可能跨越多个主题，或者不完全符合任何现有类别。这些边界案例往往具有特殊的价值：它们可能代表新兴的研究方向，或者揭示现有分类体系的局限。研究者不应强行将这些文献塞入某个类别，而应单独标记，作为进一步探索的线索。</p>
<p>第四个原则是验证聚类结果。AI生成的聚类结果需要人工验证。验证的方法包括：从每个聚类中随机抽取几篇文献，检查它们是否真的属于同一主题；检查聚类的标签是否准确反映了聚类内容；寻找是否有明显的误分类。如果发现系统性的问题，需要调整聚类指令并重新执行。</p>
</section>
<section id="一个实践案例" class="level3">
<h3 class="anchored" data-anchor-id="一个实践案例">1.4 一个实践案例</h3>
<p>为了说明上述原则的应用，我将描述一个具体的文献筛选与聚类案例。</p>
<p>假设研究者正在开展一项关于”社交媒体对学术传播影响”的研究。初步的数据库检索返回了350篇相关文献的题目和摘要。研究者的任务是从中筛选出与研究问题直接相关的文献，并对这些文献进行主题分类。</p>
<p>第一步，研究者设计了筛选指令。纳入标准包括：实证研究社交媒体（如Twitter/X、ResearchGate、Academia.edu）对学术论文传播的影响；研究涉及可测量的传播指标（如引用、阅读量、讨论度）；研究对象为学术论文或学术成果。排除标准包括：纯描述性的社交媒体使用调查；仅讨论社交媒体对教学的影响；技术性的平台分析而非传播效果研究；非英文文献。</p>
<p>第二步，研究者将350篇文献的题目和摘要提交给模型，要求模型按照上述标准进行分类。模型返回了以下结果：92篇标记为”纳入”，198篇标记为”排除”，60篇标记为”待定”。</p>
<p>第三步，研究者对结果进行人工复核。首先，研究者审阅了60篇”待定”文献，最终纳入其中的35篇，排除25篇。然后，研究者从198篇”排除”文献中随机抽取20篇进行检查，发现其中3篇实际上符合纳入标准（假阴性率约15%）。基于这个发现，研究者决定扩大抽查范围，又检查了30篇”排除”文献，额外发现了4篇应当纳入的文献。最终的纳入文献数量为134篇。</p>
<p>第四步，研究者对134篇纳入文献进行主题聚类。第一轮聚类识别出四个大主题：（1）社交媒体与引用影响；（2）社交媒体与公众传播；（3）学术社交网络平台研究；（4）社交媒体使用行为研究。第二轮聚类在每个大主题下进一步细分。例如，“社交媒体与引用影响”下细分为”Twitter讨论与引用相关性”“Altmetrics指标研究”“因果效应估计”三个子主题。</p>
<p>第五步，研究者验证聚类结果。从每个子主题中抽取3篇文献进行审阅，确认分类的准确性。在验证过程中发现，“Altmetrics指标研究”这个子主题过于宽泛，包含了指标本身的研究和指标应用的研究两类不同性质的文献，需要进一步拆分。</p>
<p>通过这个案例可以看到，AI在筛选和聚类过程中发挥了重要的辅助作用，显著减少了人工处理的工作量。但每个关键节点都有人工的参与和验证，确保了最终结果的可靠性。</p>
</section>
</section>
<section id="二长上下文模型的正确用法" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="二长上下文模型的正确用法"><span class="header-section-number">5.3</span> 二、长上下文模型的正确用法</h2>
<section id="长上下文能力的本质与局限" class="level3">
<h3 class="anchored" data-anchor-id="长上下文能力的本质与局限">2.1 长上下文能力的本质与局限</h3>
<p>近年来，大语言模型的上下文窗口经历了显著扩展。早期的模型只能处理几千个token，而最新的模型已经能够处理数十万甚至上百万个token。这意味着研究者理论上可以将几十篇论文的全文一次性输入模型，要求模型进行综合分析。</p>
<p>然而，“能够处理”不等于”能够有效处理”。研究表明，即使是长上下文模型，其在不同位置的信息利用效率也存在显著差异。一般而言，模型对上下文开头和结尾的信息利用较好，而对中间部分的信息利用较差——这被称为”中间丢失”现象。此外，当上下文过长时，模型生成的回答往往变得更加泛化和模糊，丢失了对具体细节的把握。</p>
<p>这些发现对学术研究有重要启示。将大量论文一次性输入模型，期望获得一个全面准确的综合分析，这种期望是不现实的。更有效的策略是理解长上下文的局限，设计相应的使用方法。</p>
</section>
<section id="分层处理策略" class="level3">
<h3 class="anchored" data-anchor-id="分层处理策略">2.2 分层处理策略</h3>
<p>面对长上下文的局限，我建议采用分层处理策略。这个策略的核心思想是：不要试图让模型一次完成所有工作，而是将任务分解为多个层次，每个层次处理适量的信息。</p>
<p>第一层是单篇论文的信息提取。对于每一篇需要纳入分析的论文，首先单独提取关键信息。提取的内容可能包括：研究问题、理论框架、研究方法、核心发现、主要结论、局限性。这个层次的任务相对简单，模型通常能够较好地完成。研究者可以设计一个标准化的提取模板，确保从每篇论文中获取可比较的信息。</p>
<p>第二层是小组论文的比较分析。将具有相似主题或方法的3-5篇论文组成一个小组，要求模型对这个小组进行比较分析。比较的维度可能包括：研究发现的一致性与差异、方法论的异同、理论框架的关系。这个层次的任务开始涉及综合和推理，模型的表现会有更大的不确定性，需要研究者的仔细审核。</p>
<p>第三层是跨组的综合归纳。在完成所有小组的分析之后，将各组的分析结果作为输入，要求模型进行更高层次的综合。这个层次的输入是已经经过压缩和结构化的信息，而非原始的论文全文，因此更适合模型处理。</p>
<p>这种分层策略的优势在于：每一层的任务都保持在模型能够有效处理的范围内；每一层都有明确的输出，便于人工审核和质量控制；错误可以在较早的层次被发现和纠正，而不会传递到最终输出。</p>
</section>
<section id="输入质量的重要性" class="level3">
<h3 class="anchored" data-anchor-id="输入质量的重要性">2.3 输入质量的重要性</h3>
<p>长上下文模型的输出质量高度依赖于输入的质量。“垃圾进，垃圾出”的原则在这里尤其适用。研究者在准备输入材料时，应当注意以下几点。</p>
<p>首先是格式的一致性。如果输入的材料格式混乱——有的是纯文本，有的是PDF提取的乱码，有的包含大量表格和图片描述——模型的处理效果会大打折扣。研究者应当在输入之前对材料进行预处理，确保格式的统一和清洁。</p>
<p>其次是信息的相关性。不是论文的所有部分都与研究者的分析需求相关。如果研究者只关心研究方法和发现，那么将论文的致谢、参考文献列表、补充材料等全部输入模型，不仅浪费了上下文空间，还可能引入噪音。研究者应当有选择地提取和输入最相关的部分。</p>
<p>第三是结构的清晰性。在输入多篇论文时，应当使用清晰的分隔符和标识，让模型能够区分不同论文的内容。例如，可以在每篇论文的开头添加标识：“[论文1] 作者：xxx，标题：xxx，年份：xxx”。这种结构化的输入有助于模型准确地引用和归因。</p>
</section>
<section id="输出设计与质量控制" class="level3">
<h3 class="anchored" data-anchor-id="输出设计与质量控制">2.4 输出设计与质量控制</h3>
<p>除了优化输入，研究者还应当精心设计期望的输出格式，并建立相应的质量控制机制。</p>
<p>在输出设计方面，研究者应当明确告诉模型输出的结构和详细程度。例如：“请按以下格式输出：（1）主要发现综述（200字以内）；（2）研究方法比较表格；（3）发现一致性分析；（4）发现差异分析；（5）研究空白识别。”结构化的输出要求不仅便于后续使用，也使得质量检查更加系统化。</p>
<p>在质量控制方面，最重要的原则是可追溯性。模型的每一个陈述都应当能够追溯到具体的原始来源。研究者可以要求模型在输出中标注来源，例如：“Smith等（2020）发现社交媒体讨论与引用存在正相关[论文3]”。然后研究者需要回到原始论文验证这个陈述是否准确。</p>
<p>另一个重要的质量控制方法是交叉验证。对于同一批论文，可以从不同的角度或使用不同的指令让模型进行分析，然后比较结果的一致性。如果两次分析得出截然不同的结论，说明至少有一次分析存在问题，需要人工介入检查。</p>
</section>
<section id="一个错误使用的案例" class="level3">
<h3 class="anchored" data-anchor-id="一个错误使用的案例">2.5 一个错误使用的案例</h3>
<p>为了说明不当使用长上下文模型的风险，我将描述一个反面案例。</p>
<p>一位研究生正在撰写一篇关于数字鸿沟的文献综述。他收集了45篇相关论文的PDF文件，使用工具将这些PDF转换为文本，然后一次性将所有文本（约50万字）输入一个长上下文模型，要求模型”写一篇全面的文献综述，总结这45篇论文的主要发现和研究趋势”。</p>
<p>模型生成了一篇约3000字的综述，结构完整，语言流畅。这位研究生非常满意，稍作修改后就准备使用。但他的导师要求他核对其中几个关键陈述的来源。</p>
<p>核对的结果令人担忧。综述中的一个陈述是：“Chen等（2019）的元分析发现，数字鸿沟对教育成就的影响效应量为d=0.42。”但当研究生查找这篇论文时，发现Chen等（2019）的研究根本不是元分析，而是一项单一的调查研究，也没有报告过d=0.42这个效应量。另一个陈述是：“近年来的研究趋势从关注接入差距转向关注使用差距和技能差距。”这个陈述本身可能是正确的，但模型没有提供任何具体证据，研究生也无法追溯这个”趋势”判断的来源。</p>
<p>这个案例说明了几个问题。第一，将大量未经预处理的材料一次性输入模型，模型无法有效利用所有信息。第二，期望模型一次性完成复杂的综合任务，超出了模型的可靠能力范围。第三，没有建立验证机制，导致错误直到被要求核对时才被发现。第四，模型生成的流畅文本给研究者造成了虚假的信心，掩盖了内容上的问题。</p>
<p>正确的做法应该是采用前文描述的分层处理策略：先对每篇论文单独提取信息，然后分组比较，最后综合归纳，每一步都进行验证。</p>
</section>
</section>
<section id="三可信综述生成引用与验证" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="三可信综述生成引用与验证"><span class="header-section-number">5.4</span> 三、可信综述生成：引用与验证</h2>
<section id="为什么综述生成是高风险任务" class="level3">
<h3 class="anchored" data-anchor-id="为什么综述生成是高风险任务">3.1 为什么综述生成是高风险任务</h3>
<p>文献综述是学术写作中最常见也是最容易被AI辅助的任务之一。但它同时也是风险最高的任务之一。这种高风险源于几个因素。</p>
<p>第一，综述涉及对多个来源的准确归纳。模型不仅需要理解每一篇论文的内容，还需要准确地表述每篇论文说了什么、没说什么。任何一个错误归纳都可能误导读者，损害综述的可信度。</p>
<p>第二，综述需要准确的引用。学术写作的核心规范之一是”言必有据”——每一个关于先前研究的陈述都应当有明确的来源。模型生成虚假引用的问题在学术界已经广为人知。即使引用的论文确实存在，模型对其内容的概括也可能不准确。</p>
<p>第三，综述涉及判断和评价。好的综述不仅仅是论文的罗列，还需要对研究进行评价、识别研究空白、提出未来方向。这些任务需要深入的领域知识和批判性思维，超出了当前模型的可靠能力范围。</p>
<p>第四，综述的错误难以被非专家发现。一篇语言流畅、结构合理的综述，即使内容有问题，读者也很难察觉。尤其是当读者没有阅读过原始论文时，他们无法判断综述的归纳是否准确。</p>
<p>基于这些风险，我建议将综述生成视为”高风险任务”，采用最严格的验证机制。</p>
</section>
<section id="ai在综述生成中的适当角色" class="level3">
<h3 class="anchored" data-anchor-id="ai在综述生成中的适当角色">3.2 AI在综述生成中的适当角色</h3>
<p>尽管风险很高，AI在综述生成中仍然可以发挥有价值的辅助作用，只要研究者正确定位AI的角色。</p>
<p>AI适合承担的任务包括：生成初步的组织框架、识别可能的主题分类、对单篇论文进行摘要、提示可能被遗漏的角度。这些任务的共同特点是：它们是”启发性”的而非”结论性”的——AI的输出是供研究者参考和修改的草稿，而非最终产品。</p>
<p>AI不适合承担的任务包括：对论文观点的权威性概括、对研究质量的评价、对研究领域的趋势判断、任何需要作为最终产品使用的内容。这些任务需要研究者自己完成，或者在AI辅助的基础上进行充分的人工审核和修改。</p>
<p>一个有用的思维框架是区分”生成”和”使用”两个阶段。在生成阶段，研究者可以自由地使用AI来探索想法、生成草稿、获取灵感。在使用阶段——也就是将内容放入最终的学术产品中——每一个陈述都必须经过验证，确保其准确性和可追溯性。</p>
</section>
<section id="引用验证的系统方法" class="level3">
<h3 class="anchored" data-anchor-id="引用验证的系统方法">3.3 引用验证的系统方法</h3>
<p>引用验证是综述生成中最关键的质量控制环节。我建议采用系统化的验证方法。</p>
<p>第一步是列出所有引用。将AI生成的综述中所有的文献引用提取出来，形成一个完整的列表。每个引用应当记录：作者、年份、被引用的具体观点或发现。</p>
<p>第二步是验证引用的存在性。确认每一篇被引用的文献确实存在。检查作者姓名、发表年份、期刊或会议名称是否正确。使用Google Scholar、Web of Science或其他数据库进行验证。如果发现一篇文献不存在或信息有误，这是一个明确的红旗，需要删除该引用并检查AI输出中的其他引用。</p>
<p>第三步是验证引用的准确性。这是最耗时但也是最重要的步骤。对于每一个引用，回到原始论文，确认综述中的概括是否准确反映了原文的观点。常见的问题包括：夸大了原文的发现、忽略了原文的限定条件、将原文的假设表述为结论、混淆了不同论文的内容。</p>
<p>第四步是标记验证状态。为每个引用标记验证状态：已验证、待验证、存疑、已删除。这个标记帮助研究者追踪验证进度，确保没有遗漏。</p>
<p>第五步是迭代修正。根据验证结果修正综述内容。对于发现的错误，不仅要修正具体的陈述，还要反思错误的模式——是某一类论文的概括容易出错，还是某一种陈述类型容易出错？这种反思有助于改进后续的工作流程。</p>
</section>
<section id="建立可追溯的证据链" class="level3">
<h3 class="anchored" data-anchor-id="建立可追溯的证据链">3.4 建立可追溯的证据链</h3>
<p>可信的综述不仅需要引用准确，还需要建立清晰的证据链，使读者能够追溯任何陈述的来源。</p>
<p>证据链的建立始于数据管理。研究者应当建立一个结构化的文献数据库，记录每篇论文的基本信息、核心内容摘要、以及在综述中如何被使用。文献管理软件如Zotero、EndNote、Mendeley可以支持这一工作，但研究者需要超越简单的书目管理，为每篇文献添加结构化的笔记和标签。</p>
<p>证据链的维护贯穿写作过程。在综述写作的每一个阶段，研究者都应当能够回答：这个陈述的依据是什么？来自哪篇文献的哪个部分？如果无法回答这些问题，说明证据链存在断裂，需要补充或修正。</p>
<p>证据链的最终呈现体现在综述文本中。读者应当能够通过引用信息找到原始来源，并验证综述中的陈述。这要求引用必须具体和准确——引用到具体的页码或章节，而非笼统地引用整篇论文。</p>
</section>
<section id="ai辅助综述的披露与伦理" class="level3">
<h3 class="anchored" data-anchor-id="ai辅助综述的披露与伦理">3.5 AI辅助综述的披露与伦理</h3>
<p>使用AI辅助生成学术综述涉及伦理问题，研究者有责任进行适当的披露。</p>
<p>不同的学术机构和期刊对AI使用的披露要求不同。有些要求详细说明AI在写作中的角色，有些只要求声明是否使用了AI，有些尚未制定明确的政策。研究者应当了解并遵守相关的规定。</p>
<p>即使没有明确的披露要求，透明度也是学术诚信的基本原则。我建议在使用AI辅助综述生成时，至少在方法部分说明：使用了哪些AI工具、AI在哪些环节发挥了作用、研究者采取了哪些验证措施。这种披露不会减损研究的价值，反而展示了研究者的方法论自觉。</p>
<p>需要强调的是，披露AI的使用并不能免除研究者对最终内容的责任。无论AI在生成过程中扮演了多大的角色，发表的内容归研究者所有，研究者对其准确性和诚信性负有完全的责任。AI是工具，而使用工具的方式——以及对工具输出的把关——是研究者的选择和责任。</p>
</section>
</section>
<section id="四从工具到能力信息素养的新维度" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="四从工具到能力信息素养的新维度"><span class="header-section-number">5.5</span> 四、从工具到能力：信息素养的新维度</h2>
<section id="信息压缩作为研究者的核心能力" class="level3">
<h3 class="anchored" data-anchor-id="信息压缩作为研究者的核心能力">4.1 信息压缩作为研究者的核心能力</h3>
<p>本章的讨论可能给读者一个印象：AI正在接管文献整理的工作。但我想在结束时强调一个相反的观点：信息压缩是研究者的核心能力，AI的参与不应削弱这一能力的培养。</p>
<p>信息压缩能力包括几个层面。第一个层面是快速识别信息价值的能力——看一篇论文的摘要，就能判断它与研究问题的相关程度。第二个层面是提取核心论点的能力——阅读一篇论文，能够准确把握其主要贡献和局限。第三个层面是综合多个来源的能力——将多篇论文的发现整合为连贯的知识图景。第四个层面是识别知识空白的能力——看到现有文献的整体轮廓，能够发现尚未被研究的问题。</p>
<p>这些能力需要通过实践来培养。阅读大量论文、写作多篇综述、经历导师的反馈和修改——这个过程不能被跳过或压缩。AI可以帮助提高效率，但不能替代学习过程本身。</p>
</section>
<section id="人机协作的最优配置" class="level3">
<h3 class="anchored" data-anchor-id="人机协作的最优配置">4.2 人机协作的最优配置</h3>
<p>对于研究者而言，关键问题是：如何配置人类和AI在文献整理工作中的角色，以实现最优的结果？</p>
<p>我建议的配置原则是：AI负责规模化处理和格式化任务，人类负责判断和验证任务。</p>
<p>在文献筛选中，AI可以处理数百篇文献的初步分类，人类负责边界情况的判断和分类准确性的验证。在主题聚类中，AI可以提供初步的聚类方案，人类负责评估聚类的合理性并进行调整。在信息提取中，AI可以从论文中提取结构化信息，人类负责检查提取的准确性。在综述写作中，AI可以协助生成草稿和组织框架，人类负责内容的验证、判断和最终表述。</p>
<p>这种配置的核心逻辑是：利用AI的速度优势处理那些规则明确、可批量执行的任务，同时保留人类对关键节点的控制权。人类的时间和认知资源应当集中在那些真正需要专业判断的环节。</p>
</section>
<section id="未来研究者的信息素养" class="level3">
<h3 class="anchored" data-anchor-id="未来研究者的信息素养">4.3 未来研究者的信息素养</h3>
<p>AI工具的普及正在改变研究者所需的信息素养。传统的信息素养强调检索技能——如何使用数据库、如何构建检索策略、如何管理文献。这些技能仍然重要，但不再足够。</p>
<p>未来的研究者需要掌握新的信息素养。第一是AI素养——理解AI工具的能力和局限，知道如何有效地使用它们，也知道在什么情况下不应该使用它们。第二是验证素养——能够系统地检查AI输出的准确性，建立可追溯的证据链，识别和纠正错误。第三是工作流设计素养——能够设计人机协作的工作流程，优化任务在人类和AI之间的分配。第四是元认知素养——保持对自己认知过程的反思，避免因过度依赖AI而导致的能力退化。</p>
<p>这些素养不会自动获得，需要有意识地培养。研究者应当在实践中不断反思自己使用AI的方式，评估效果，调整策略。学术机构和导师也应当为研究生提供相关的培训和指导。</p>
</section>
</section>
<section id="结语" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="结语"><span class="header-section-number">5.6</span> 结语</h2>
<p>本章讨论了AI辅助文献整理的方法和原则。核心论点可以总结为：AI能够显著提高信息压缩的效率，但这种效率提升必须以可靠性为前提。研究者应当把AI的输出视为”索引”而非”结论”，是需要验证的起点而非可以信任的终点。</p>
<p>在文献筛选中，两阶段模型——AI辅助粗筛加人工复核精筛——能够在效率和准确性之间取得平衡。在使用长上下文模型时，分层处理策略能够避免信息过载导致的质量下降。在综述生成中，严格的引用验证和证据链管理是确保可信度的必要措施。</p>
<p>贯穿这些讨论的，是对研究者主体性的强调。AI改变了文献整理的方式，但没有改变文献整理的目的——那就是建立研究者对一个领域的深入理解。这种理解不能被外包给机器，只能通过研究者自己的阅读、思考和综合来建立。AI是这个过程中的有力工具，但工具的价值最终取决于使用工具的人。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/yuzhangsjtu\.github\.io\/AAAR\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../outline/03-提示词不是方法论.html" class="pagination-link" aria-label="第3章 提示词不是方法论">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">第3章 提示词不是方法论</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../outline/05-结构化表达与写作.html" class="pagination-link" aria-label="第5章 结构化表达与写作">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">第5章 结构化表达与写作</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/yuzhangsjtu/AAAR/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>